\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc}  % Unicode
\usepackage[french]{babel}
\usepackage{geometry}
\usepackage{graphics}
\usepackage[pdftex]{graphicx, color}
\usepackage{pdfpages}
\DeclareGraphicsExtensions{.jpg,.png}
\pdfoutput=1
\usepackage[pdftex,
	bookmarks = true,           % Signets
	bookmarksnumbered = true,   % Signets numerotes
	pdfstartview = FitV,        % La page prend toute la hauteur
	colorlinks=true,
	citecolor=black,urlcolor=blue,linkcolor=black,
	pdfauthor={Auteur},
	pdftitle={Titre},
 	pdfsubject={Sujet},
%	pdfkeywords={},	% Besoin de keywords ?
	plainpages=false,
	pdfpagelabels,
	breaklinks=true,
   	hyperindex,
	linktocpage=true	% pour colorier seulement le numéros dans la TOC	
]{hyperref}
\usepackage{float}
\usepackage{listings}
\usepackage{alltt}
\usepackage{amsmath}
\renewcommand{\ttdefault}{txtt}

\lstset{basicstyle=\ttfamily,
escapeinside={||},
mathescape=true}
\setcounter{secnumdepth}{3}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\newcommand*\styleC{\fontsize{9}{10pt}\selectfont }
\newcommand*\styleD{\fontsize{9}{10pt}\usefont{OT1}{pag}{m}{n}\selectfont }

\makeatletter
% on fixe le langage utilisé
\lstset{language=matlab}
\edef\Motscle{emph={\lst@keywords}}
\expandafter\lstset\expandafter{
}
\makeatother



\definecolor{Ggris}{rgb}{0.45,0.48,0.45}

\lstset{emphstyle=\ttfamily\color{blue}, % les mots réservés de matlab en bleu
basicstyle=\ttfamily\styleC, % 
keywordstyle=\ttfamily,
commentstyle=\color{Ggris}\styleD, % \styleD commentaire en gris
numberstyle=\tiny\color{black},
numbers=left,
numbersep=10pt,
lineskip=0.7pt,
showstringspaces=false}
%  % inclure le fichier source
\newcommand{\FSource}[1]{%
\lstinputlisting[texcl=true]{#1}
}

%%%%%%%%%
\textwidth=15cm
\textheight=21cm
%\hoffset=-2.5cm
\tolerance=9000
\hbadness=9000
\pretolerance=2500


\begin{document}
%\rmfamily

\input{title.tex}

%\begin{abstract} 
%\end{abstract} 

%{\bf Keywords:} \newline


\clearpage

\section{Introduction}

Le but de ce TP est de mettre en oeuvre la technique du block matching utilisée dans certains algorithmes de compression vidéo.

\section{Mise en oeuvre du block matching}

\subsection{Padding de l'image}

La division de l'image en bloc implique que la largeur et la hauteur de l'image soient respectivement multiples de la largeur et de la hauteur des blocs. Si ce n'est pas le cas, nous complétons avec des zéros (pixels noirs) grâce à la fonction padarray. Pour calculer le nombre de pixels à rajouter en largeur on utilise la formule suivante : \\

\begin{center}
	$(M - (largeur(image) \mod M)) \mod M$ \\
\end{center}
avec M largeur d'un bloc.

\begin{figure}[H]
	\centering
		\includegraphics[height=6cm]{../Resultats/Garden/garden_padding.jpg}
	\caption{Image, issue de la video garden, que l'on a voulu diviser en bloc de 7x7. L'image faisant 352x240, il a fallu rajouter 5 pixels noirs en largeur et 5 en hauteur.}
	\label{fig:padding}
\end{figure}

\subsection{Calcul de la fenêtre de recherche}

\subsection{Recherche du meilleur bloc}

\newpage
\section{Résultats}

Pour montrer nos résultats, nous allons utiliser deux images issue de la séquence garden (très utilisée dans le domaine du traitement vidéo, comme Lena pour le traitement des images). Voici les deux images que nous allons utiliser : 

\begin{figure}[H]
	\centering
	\includegraphics[height=5cm]{../garden1.jpg}
	\includegraphics[height=5cm]{../garden2.jpg}
	\caption{Frames 2 et 5 de la séquence garden}
	\label{fig:garden}
\end{figure}

Le MSD entre ces deux images s'élève à 3465. Voici l'image résultante de la différence entre l'image courante (Frame 5) et l'image de référence (Frame 2) :

\begin{figure}[H]
	\centering
	\includegraphics[height=7cm]{../Resultats/Garden/garden_error.jpg}
	\caption{Différence entre image courante et image de référence}
	\label{fig:garden_error}
\end{figure}

On commence par un effectuer un block matching avec des blocs d'une taille 7x7 et une fenêtre de recherche de 17x17 (ou moins selon la position du bloc courant dans l'image) :

\begin{figure}[H]
	\centering
	\includegraphics[height=5cm]{../Resultats/Garden/garden_pred_n_3_w_5.jpg}
	\includegraphics[height=5cm]{../Resultats/Garden/garden_error_n_3_w_5.jpg}
	\caption{Image courante prédite et erreur de prédiction pour $N=3$ et $W=5$. Le MSD est alors de 1128.}
	\label{fig:garden_3_5}
\end{figure}

On passe ensuite à des blocs 3x3 et une fenêtre de recherche 33x33. On devra donc analyser beaucoup plus de positions mais la prédiction sera beaucoup plus fine. En effet on voit que le MSD tombe à 188 :

\begin{figure}[H]
	\centering
	\includegraphics[height=5cm]{../Resultats/Garden/garden_pred_n_1_w_15.jpg}
	\includegraphics[height=5cm]{../Resultats/Garden/garden_error_n_1_w_15.jpg}
	\caption{Image courante prédite et erreur de prédiction pour $N=1$ et $W=15$. Le MSD tombe alors à 188.}
	\label{fig:garden_1_15}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[height=8cm]{../Resultats/Garden/garden_graph.jpg}
	\caption{Evolution du MSD et du temps de calcul en fonction de M et W}
	\label{fig:garden_graph}
\end{figure}

On observe que plus la fenêtre de recherche est grande, plus le MSD sera faible, mais plus le temps de calcul sera important. Et inversement pour la taille des blocs. Plus les blocs seront grands, plus le MSD sera important et moins le temps de calul sera important.



\newpage

\section{Conclusion}


\clearpage

%
% ANNEXE
%
\appendix

\section{Codes source MATLAB}

\subsection{Calcul du MSD}\label{msd_code}

\FSource{../compute_msd.m}

\newpage

\subsection{Calcul de la fenêtre de recherche}\label{search_window}

\FSource{../search_window.m}

\newpage

\subsection{Recherche d'un bloc dans l'image de référence}\label{block_search}

\FSource{../block_matching.m}

\newpage

\subsection{Block Matching}\label{block_matching}

\FSource{../block_matching_encode.m}


\end{document}