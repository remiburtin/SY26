\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc}  % Unicode
\usepackage{geometry}
\usepackage{graphics}
\usepackage[pdftex]{graphicx, color}
\usepackage{pdfpages}
\DeclareGraphicsExtensions{.jpg,.png}
\pdfoutput=1
\usepackage[pdftex,
	bookmarks = true,           % Signets
	bookmarksnumbered = true,   % Signets numerotes
	pdfstartview = FitV,        % La page prend toute la hauteur
	colorlinks=true,
	citecolor=black,urlcolor=blue,linkcolor=red,
	pdfauthor={Auteur},
	pdftitle={Titre},
 	pdfsubject={Sujet},
%	pdfkeywords={},	% Besoin de keywords ?
	plainpages=false,
	pdfpagelabels,
	breaklinks=true,
   	hyperindex,
	linktocpage=true	% pour colorier seulement le numéros dans la TOC	
]{hyperref}
\usepackage{float}
\usepackage{listings}
\usepackage[french]{babel}

\geometry{left=18mm,right=18mm,top=21mm,bottom=21mm}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\newcommand*\styleC{\fontsize{9}{10pt}\selectfont }
\newcommand*\styleD{\fontsize{9}{10pt}\usefont{OT1}{pag}{m}{n}\selectfont }

\makeatletter
% on fixe le langage utilisé
\lstset{language=matlab}
\edef\Motscle{emph={\lst@keywords}}
\expandafter\lstset\expandafter{%
  \Motscle}
\makeatother


\definecolor{Ggris}{rgb}{0.45,0.48,0.45}

\lstset{emphstyle=\ttfamily\color{blue}, % les mots réservés de matlab en bleu
basicstyle=\ttfamily\styleC, % 
keywordstyle=\ttfamily,
commentstyle=\color{Ggris}\styleD, % \styleD commentaire en gris
numberstyle=\tiny\color{black},
numbers=left,
numbersep=10pt,
lineskip=0.7pt,
showstringspaces=false}
%  % inclure le fichier source
\newcommand{\FSource}[1]{%
\lstinputlisting[texcl=true]{#1}
}

%%%%%%%%%
\textwidth=15cm
\textheight=21cm
%\hoffset=-2.5cm
\tolerance=9000
\hbadness=9000
\pretolerance=2500





\begin{document}
%\rmfamily

\input{title.tex}

%\begin{abstract} 
%\end{abstract} 

%{\bf Keywords:} \newline


\clearpage

\section{Introduction}
L'objectif de ce TP est de comparer le codage de Huffman au codage arithmétique. Pour cela, nous travaillons sur une image ('lena.bmp') en niveaux de gris, ce qui permet de fixer une seule valeur (entre 0 et 255) pour chaque pixel de l'image. Nous avons donc réalisé deux scripts, chacun codant et décodant une image en utilisant un des deux algorithmes.

\section{Codeur de Huffman}

\subsection{Mise en oeuvre}

L'image que nous manipulons pour réaliser l'encodage/décodage selon Huffman ne contient qu'une seule composante correspondant à l'intensité du gris. Pour convertir une image couleur en niveaux de gris, nous utilisons la fonction \textit{rgb2gray} qui retourne une matrice à deux dimensions, de même taille que l'image.\\

Afin de réaliser l'encodage, il est nécessaire de connaître la distribution de probabilités des niveaux de gris de l'image. Pour cela, nous commençons par réaliser l'histogramme comptant le nombre d'occurrences de chaque valeur de gris. L'histogramme est en fait un vecteur de taille 256, ce qui correspond aux différentes valeurs de gris. Ainsi, à l'index $x\in[1, 256]$, nous obtenons le nombre d’occurrences de cette intensité de gris dans l'image. Afin d'obtenir une distribution de probabilités ($\sum P(X=x_{i}) = 1$), nous normalisons l'histogramme en divisant chaque valeur de l'histogramme par le nombre total de pixels dans l'image. \\

\begin{figure}[H]
\begin{center}
	 \includegraphics[scale=0.6]{../proba.jpg}
	 \caption{\label{probaGris} Distribution de probabilités, niveaux de gris}
\end{center}
\end{figure}

L'algorithme d'Huffman fonctionne de sorte que les symboles ayant la moins grande probabilité prennent des valeurs les plus grande dans le dictionnaire, afin d'améliorer la compression. Dans le cas de notre image, beaucoup d'intensités de gris n'apparaissent pas dans l'image : elles correspondent aux indexes de l'histogramme ayant pour valeur 0. Afin de supprimer ces valeurs inutiles lors de la création du dictionnaire, nous créons un nouvel histogramme, ayant des valeurs toutes strictement positives. Ce nouvel histogramme pourra alors avoir à l'index 1, le niveaux de gris 30. (si les 30 premiers niveaux de gris n'apparaissent pas dans l'image). Afin de reconstruire l'image originale après encodage/décodage, nous devons alors établir une table de correspondance. Ainsi, chaque index de l'histogramme devra être lié à une valeur d'un niveaux de gris présent dans l'image. \\

Selon la longueur de l'histogramme sans zéro, nous créons un dictionnaire avec les nouveaux symboles allant de 0 à L, L étant la taille du nouvel histogramme. Dans le tableau~\ref{tab:Histogrammes} page~\pageref{tab:Histogrammes}, nous associons le nombre d'occurrences de chaque niveaux de gris. Afin de construire le dictionnaire via le codeur de Huffman, nous devons créer les probabilités qui en découle (en normalisant l'histogramme). Chaque effectif est alors divisé par le nombre total des effectifs, soit ici le nombre de pixels. \\

\begin{table}[!h]
	\centering
		\begin{tabular}{|c c|c c c|}
			\hline 
			\multicolumn{2}{|c|}{Histogramme simple} & \multicolumn{3}{|c|}{ Histogramme sans zéros } \\
			\hline Index & Effectif & Index & Effectif & Niveau de gris\\
			\hline
						1 & 0 & 1  & 2 & 3 \\
						2 & 0 & 2  & 6 & 5\\
						3 & 2 & 3  & 7 & 6\\
						4 & 0 &  & &  \\
						5 & 6 &  & &  \\
						6 & 7 &  & &  \\
						7 & 0 &  & & 	\\
						8 & 0 &  & & 	\\
			\hline
		\end{tabular}
	\caption{Exemple - Histogrammes}
	\label{tab:Histogrammes}
	\vspace{1cm}
\end{table}




\begin{table}[!h]
	\centering
		\begin{tabular}{|c|c|}
			\hline 
				Index (Histogramme sans zéro) & Niveau de gris associé \\
			\hline 
				1 & 3 \\
				2 & 5 \\
				3 & 6 \\
			\hline
		\end{tabular} \\
	\caption{Exemple - Table de correspondance}
	\label{tab:TableDeCorrespondance}
\end{table}

	L'index de l'histogramme sans zéro correspond à un symbole lors de la création du dictionnaire par la fonction \textit{huffmandict}.


\subsection{Résultats}

Nous affichons un log grâce à la fonction \textit{disp} :

\begin{verbatim}
>> huffman('../lena.bmp')
Lecture de l'image ../lena.bmp
Image couleur : conversion en gris
Creation vecteur des probalites des niveaux de gris
Creation du vecteurs des differents symboles, nombre de symboles : 217
Creation du dictionnaire (via huffmandict())
Longueur moyenne des mots encodes : 7.4675
Encodage de l'image
Decodage de l'image
Duree encodage/decodage : 131.098s.
Taux de compression : 1 - taille finale / taille initiale = 0.066566
Taux de compression : 1 - longueur moyenne mot code / 8 = 0.066566
\end{verbatim}
\section{Codeur arithmétique}

\section{Conclusion}


\clearpage
\appendix

\section{Codes source MATLAB}
\subsection{Algorithme - codage de Huffman}\label{algohuffman}

\FSource{../huffman.m}

\newpage
\subsection{Algorithme - codage arithmétique}\label{algoarithmetique}

\FSource{../arith.m}

\end{document}